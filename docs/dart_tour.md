# Основы Dart

Попробовать Dart можно [тут](https://dartpad.dartlang.org/).

## Простая программа на Dart

Следующий код использует большую часть основных возможностей языка Dart:

```dart
// Объявление функции.
printInteger(int aNumber) {
  print('The number is $aNumber.'); // печать в консоль.
}

// Здесь программа начинает исполнение.
main() {
  var number = 42; // Объявление и инициализация переменной.
  printInteger(number); // Вызов функции.
}
```

Здесь перечислено то, что используют все ( *или почти все* ) программы на Dart:

`// Это комментарий` Однострочный комментарий. Dart так же поддерживает многострочные комментарии и документацию. Об этом вы узнаете в разделе комментарии.

`int` Типы данных. Вот еще несколько встроенных типов `String, List, bool`.

`42` Числовые литералы. Являются своего рода константой времени компиляции.

`print()` Удобный способ вывода данных в консоль.

`'...' (или "...")` Строковые литералы.

`$variableName (или ${expression})` Строковая интерполяция: в том числе переменная или эквивалент выражения внутри строкового литерала. Детальная информация в разделе Строки.

`main()` Специальная, обязательная функция с которой начинается выполнение приложения. см main()

`var` Способ объявления переменной без указания ее типа.

## Важные понятия

На протяжении знакомства с языком Dart, помните это:

- Все что вы можете поместить в переменную является объектом, а каждый объект является экземпляром класса. Числа, функции и даже `null` - объекты. Все объекты наследуются от класса [Object](https://api.dartlang.org/stable/2.3.1/dart-core/Object-class.html)

- Dart строго типизирован, но аннотации типов являются не обязательными, потому что Dart может выводить типы самостоятельно. Если вы хотите явно указать что тип не ожидается, используйте `dynamic`

- Dart поддерживает универсальные типы (*generic types*), например `List<int>`(список целых чисел) или `List<dynamic>`(список объектов любого типа)

- Dart поддерживает функции верхнего уровня (например `main()`), а также функции, связанные с классом или объектом(static and instance methods, respectively). Так же вы можете создавать функции внутри функций(вложенные или локальные).

- Так же Dart поддерживает переменные верхнего уровня, привязанные к классу или объекту(статические и переменные экземпляра)(static & instance). Переменные экземпляра иногда называют полями или свойствами(fields or properties).

- В отличие от Java, в Dart нет ключевых слов `public`, `protected` и `private`. Если идентификатор начинается с `_` `bool _colorMode = true`, он является приватным для данной библиотеки.

- Идентификаторы могут начинаться с маленькой буквы или `_`, далее идет любая комбинация букв и цифр.

- Инструменты Dart могут сообщать о двух видах проблем: предупреждения и ошибки. Предупреждения являются лишь признаками того, что ваш код может не работать, но они не препятствуют выполнению вашей программы. Ошибки могут быть как во время компиляции, так и во время выполнения. Ошибка во время компиляции вообще не позволяет выполнить код; ошибка во время выполнения приводит к возникновению исключения во время выполнения кода.

## Переменные (Variables)

Вот пример объявления и инициализации переменной:

```dart
var name = 'Bob';
```

Переменные хранят ссылки. Тут переменная с именем `name` хранит ссылку на объект `String` со значением "Bob".

Тип переменной `name` выводится как `String`, но вы можете изменить этот тип, указав его. Если объект не ограничен одним типом укажите `Object` или `dynamic`.

```dart
dynamic name = 'Bob';
```

Другой вариант(предпочтительный), явно объявить тип:

```dart
String name = 'Bob';
```

## Значение по умолчанию

Неинициализированные переменные в Dart равны `null`. **Даже переменные с числовым типом данных**, потому что числа как и все в Dart является объектом.

```dart
int lineCount;
assert(lineCount == null);
```

> Примечание: Вызов `assert()` игнорируется в production коде. Во время разработки `assert()` выдает исключение если условие не является истинным.

## final и const

Если вы не планируете изменять значение переменной, используйте `const` или `final` вместо `var` или в дополнение к типу.

- `final variable` - может быть инициализирована только однажды, при первом её использовании.
- `const variable` - инициализируется во время компиляции.

Вот пример объявления `final` переменной:

```dart
final name = 'Bob'; // без объявления типа
final String nickname = 'Bobby';
```

Обратите внимание

```dart
final name = 'Bob';
name = 'Alice'; // переопределение переменной выбросит исключение
```

Используйте `const` для переменных, которые вы хотите сделать константными. Если переменная находится на уровне класса помечайте ее как статичную `static const`.
Помните что вы должны проинициализировать `const` при объявлении.

```dart
const bar = 1000000;
const double atm = 1.01325 * bar;
```

Ключевое слово `const` предназначено не только для объявления константных переменных. Вы также можете использовать его для создания постоянных значений, а также для объявления конструкторов, которые создают постоянные значения. Любая переменная может иметь постоянное значение.

```dart
var foo = const [];
final bar = const [];
const baz = []; // Эквивалент `const []`
```

## Встроенные типы

Dart имеет встроенную поддержку следующих типов:

- числа (int, double)
- строки (String)
- булевые выражения (bool)
- списки (массивы)
- наборы (set)
- карты (Map)
- руны (для выражения символов Юникода в строке) (Rune)
- символы (Symbol)

### Числа

В Dart числа бывают двух видов

`int` Целочисленные значения не более 64 бит, в зависимости от платформы.
В виртуальной машине Dart VM  числа могут быть от -2^63 до 2^63 -1

> В Dart скомпилированном в JavaScript числа могут быть от -2^53 до 2^53 -1

`double` 64-битные (с двойной точностью) числа с плавающей точкой, соответствует стандарту **IEEE 754**.

`int` и `double` являются подтипом `num` который включает в себя основные операторы такие как `+, -, *, /`.

Целые числа (`int (Integer)` ) - это числа без десятичной точки. Вот несколько примеров определения целочисленных литералов:

```dart
var x = 1;
var hex = 0xDEADBEEF;
```

Если число включает в себя дробную часть (число с плавающей точкой), это `double`(число с плавающей точкой).
Вот несколько примеров определения таких литералов:

```dart
var y = 1.1;
var exponents = 1.42e5;
```

Начиная с версии Dart 2.1, `int` автоматически конвертируются в `double` при необходимости:

```dart
double z = 1; // эквивалент double z = 1.0.
```

> Примечание: До Dart 2.1 было ошибкой использовать int в double контексте.

Так в Dart выглядит приведение типов из `String` в `int|double` или наоборот

```dart
// String -> int
var one = int.parse('1');
assert(one == 1);

// String -> double
var onePointOne = double.parse('1.1');
assert(onePointOne == 1.1);

// int -> String
String oneAsString = 1.toString();
assert(oneAsString == '1');

// double -> String
String piAsString = 3.14159.toStringAsFixed(2);
assert(piAsString == '3.14');
```

### String

Строка Dart представляет собой последовательность кодовых единиц UTF-16.
Вы можете использовать одинарные или двойные кавычки для создания строки:

```dart
var s1 = 'Single quotes work well for string literals.';
var s2 = "Double quotes work just as well.";
var s3 = 'It\'s easy to escape the string delimiter.';
var s4 = "It's even easier to use the other delimiter.";
```

Вы можете поместить значение выражения в строку, используя `${expression}`.
Если выражение является идентификатором, вы можете пропустить `{}`.
Чтобы получить строку, соответствующую объекту, Dart вызывает метод объекта toString ().

```dart
var s = 'string interpolation';

assert('Dart has $s, which is very handy.' ==
    'Dart has string interpolation, ' +
        'which is very handy.');
assert('That deserves all caps. ' +
        '${s.toUpperCase()} is very handy!' ==
    'That deserves all caps. ' +
        'STRING INTERPOLATION is very handy!');
```

> Примечание: Оператор == проверяет, эквивалентны ли два объекта.
Две строки эквивалентны, если они содержат одинаковую последовательность единиц кода.

Вы можете объединять строки, отступами или используя оператор `+`:

```dart
var s1 = 'String '
    'concatenation'
    " works even over line breaks.";
assert(s1 ==
    'String concatenation works even over '
        'line breaks.');

var s2 = 'The + operator ' + 'works, as well.';
assert(s2 == 'The + operator works, as well.');
```

Другой способ создания многострочной строки:
Использование трех `'` или `"""`:

```dart
var s1 = '''
You can create
multi-line strings like this one.
''';

var s2 = """This is also a
multi-line string.""";
```

Вы можете создать «raw» строку, добавив к ней префикс r:

```dart
var s = r'In a raw string, not even \n gets special treatment.';
```

### bool

Для представления логических значений Dart имеет тип с именем `bool`. Только два объекта имеют тип `bool`: логические литералы `true` и `false`,
которые являются константами времени компиляции.

Безопасность типов Dart означает, что вы не можете использовать
код вроде `if (nonbooleanValue)` или `assert (nonbooleanValue)`.
Лучше явно проверять значения, например:

```dart
// проверка на пустую строку
var fullName = '';
assert(fullName.isEmpty);

// Проверка на ноль
var hitPoints = 0;
assert(hitPoints <= 0);

// Проверка null.
var unicorn;
assert(unicorn == null);

// Проверка NaN.
var iMeantToDoThis = 0 / 0;
assert(iMeantToDoThis.isNaN);
```

### List

Возможно, самая распространенная коллекция почти в каждом языке программирования - это массив или упорядоченная группа объектов.
В Dart массивы являются объектами List, поэтому их часто называют списками.

```dart
var list = [1, 2, 3];
```

> Dart делает вывод, что список имеет тип List<int>.
Если вы попытаетесь добавить нецелые объекты в этот список,
анализатор или среда выполнения выдаст ошибку.

Списки используют индексацию с нуля, где 0 - это индекс первого элемента,
а list.length - 1 - это индекс последнего элемента.
Вы можете получить длину списка и ссылаться на элементы списка так же, как в JavaScript:

```dart
var list = [1, 2, 3];
assert(list.length == 3);
assert(list[1] == 2);

list[1] = 1;
assert(list[1] == 1);
```

Чтобы создать список, который является константой времени компиляции, добавьте const перед литералом списка:

```dart
var constantList = const [1, 2, 3];
// constantList[1] = 1; // переопределение приведет к ошибке
```

В Dart 2.3 появился оператор распространения (`...`) и оператор распространения с нулевым значением
(`...?`), Которые обеспечивают краткий способ вставки нескольких элементов в коллекцию.

```dart
var list = [1, 2, 3];
var list2 = [0, ...list];
assert(list2.length == 4);
```

Если выражение справа от оператора распространения может быть `null`, вы можете избежать исключений, используя оператор распространения с `null` значением (...?):

```dart
var list;
var list2 = [0, ...?list];
assert(list2.length == 1);
```

В Dart 2.3 также была представлена `collection if` и `collection for`, которую можно использовать для построения коллекций с использованием условий (`if`) и повторения (`for`).

```dart
var nav = [
  'Home',
  'Furniture',
  'Plants',
  if (promoActive) 'Outlet'
];
```

Вот пример использования коллекции for для управления элементами списка перед их добавлением в другой список:

```dart
var listOfInts = [1, 2, 3];
var listOfStrings = [
  '#0',
  for (var i in listOfInts) '#$i'
];
assert(listOfStrings[1] == '#1');
```

### Наборы

Набор (Sets) в Dart - это неупорядоченная коллекция уникальных элементов.

```dart
var halogens = {'fluorine', 'chlorine', 'bromine', 'iodine', 'astatine'};
```

>Примечание: Dart делает вывод, что элементы имеют тип `Set<String>`. Если вы попытаетесь добавить неправильный
тип значения в набор, анализатор или среда выполнения выдаст ошибку.

Чтобы создать пустой набор, используйте {} с предшествующим аргументом типа или присвойте {} переменной типа `Set`:

```dart
var names = <String>{};
// Set<String> names = {}; // это тоже сработает
// var names = {}; // !!создает карту(map), а не набор
```

Добавление элементов в существующий набор, происходит с помощью методов `add()` или `addAll()`:

```dart
var elements = <String>{};
elements.add('fluorine');
elements.addAll(halogens);
```

Используйте метод .length, чтобы получить количество предметов в наборе:

```dart
var elements = <String>{};
elements.add('fluorine');
elements.addAll(halogens);
assert(elements.length == 5);
```

Чтобы создать набор, который является константой времени компиляции, добавьте const перед литералом набора:

```dart
final constantSet = const {
  'fluorine',
  'chlorine',
  'bromine',
  'iodine',
  'astatine',
};
// constantSet.add('helium'); // добавление нового элемента вызовет ошибку
```

> Примечание: Начиная с Dart 2.3, наборы поддерживают операторы распространения (... и ...?) И наборы if и for, как это делают списки.

### Map

...словари
...карты

В общем, карта - это объект, который связывает ключи и значения. И ключи, и значения могут быть объектами любого типа. Каждый ключ встречается только один раз, но вы можете использовать одно и то же значение несколько раз.

```dart
var gifts = {
  // Key:    Value
  'first': 'partridge',
  'second': 'turtledoves',
  'fifth': 'golden rings'
};

var nobleGases = {
  2: 'helium',
  10: 'neon',
  18: 'argon',
};
```

> Примичание: Dart делает вывод, что gifts имеет тип Map<String, String>,
а nobleGases Map<int, String>. Если вы попытаетесь добавить значения другого типа,
это приведет к ошибке.

Вы можете создать те же объекты, используя конструктор Map:

```dart
var gifts = Map();
gifts['first'] = 'partridge';
gifts['second'] = 'turtledoves';
gifts['fifth'] = 'golden rings';

var nobleGases = Map();
nobleGases[2] = 'helium';
nobleGases[10] = 'neon';
nobleGases[18] = 'argon';
```

>Примечание: Возможно вы ожидаете увидеть `new Map()` вместо `Map()`, но начиная
с Dart2 ключевое слово `new` стало **не обязательным**.

Добавьте новую пару ключ-значение в существующую карту можно так же, как в JavaScript:

```dart
var gifts = {'first': 'partridge'};
gifts['fourth'] = 'calling birds'; // оба варианта правильны
```

Получение значений так же подобно JavaScript:

```dart
var gifts = {'first': 'partridge'};
assert(gifts['first'] == 'partridge');
```

Если вы запросите несуществующий ключ, получите `null`:

```dart
var gifts = {'first': 'partridge'};
assert(gifts['fifth'] == null);
```

Используйте .length, чтобы получить количество пар ключ-значение в карте:

```dart
var gifts = {'first': 'partridge'};
gifts['fourth'] = 'calling birds';
assert(gifts.length == 2);
```

Чтобы создать карту константой времени компиляции, добавьте `const` перед литералом карты:

```dart
final constantMap = const {
  2: 'helium',
  10: 'neon',
  18: 'argon',
};

// constantMap[2] = 'Helium'; // Изменение значения приведет к ошибке
```

Начиная с Dart 2.3, карты поддерживают операторы распространения (... и ...?) И коллекции, `if` и `for`, как списки.

### Руны

TODO

### Символы

TODO

## Функции

Dart - это объектно-ориентированный язык, поэтому даже функции являются объектами(`Object`) и имеют тип `Function`.
Это означает, что функции могут быть присвоены переменным или переданы в качестве аргументов другим функциям. Вы также можете вызвать экземпляр класса Dart, как если бы это была функция.

Пример функции:

```dart
bool isNoble(int atomicNumber) {
  return _nobleGases[atomicNumber] != null;
}
```

В Dart рекомендуется явно указывать тип возвращаемого значения в функциях, но если вы это опустите, ошибкой это не будет:

```dart
isNoble(atomicNumber) {
  return _nobleGases[atomicNumber] != null;
}
```

Для функций, которые содержат только одно выражение, вы можете использовать сокращенный синтаксис:

```dart
bool isNoble(int atomicNumber) => _nobleGases[atomicNumber] != null;
```

Синтаксис `=> expr` является сокращением для `{return expr; }`. Обозначение `=>` иногда называют синтаксисом стрелки.

>Примечание. Между стрелкой (`=>`) и точкой с запятой (`;`) может появляться только выражение, но не утверждение. Например, вы не можете поместить туда оператор `if`, но вы можете использовать условное выражение.

### Необязательные параметры

Функция может иметь два типа параметров: обязательные и необязательные. Обязательные параметры перечислены первыми, а затем все необязательные параметры. Именованные необязательные параметры также можно пометить как `@required`.

Необязательные параметры могут быть позиционными или именованными, но не обоими.

#### Необязательные именованные параметры

При вызове функции вы можете указать именованные параметры, используя `paramName: value`.
Например:

```dart
enableFlags(bold: true, hidden: false);
```

При определении функции используйте `{param1, param2,…}` для указания именованных параметров:

```dart
/// Устанавливае [bold] и [hidden] флаги ...
void enableFlags({bool bold, bool hidden}) {...}
```

Создание экземпляров во Flutter могут быть сложными,
поэтому конструкторы виджетов используют исключительно именованные параметры.
Это облегчает чтение выражений при создания экземпляров.

```dart
const Scrollbar({Key key, @required Widget child})
//При создании полосы прокрутки анализатор сообщает о проблеме, когда дочерний аргумент отсутствует.
```

> @required содержится в `meta package`. Либо `import package:meta/meta.dart` , либо `import другой пакет` содержащий в себе `meta`, например во Flutter `package:flutter/material.dart`.

#### Необязательные позиционные параметры

Обертывание набора параметров функции в [] помечает их как необязательные позиционные параметры:

```dart
String say(String from, String msg, [String device]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  return result;
}
```

Вот пример вызова этой функции без необязательного параметра:

```dart
assert(say('Bob', 'Howdy') == 'Bob says Howdy');
```

И вот пример вызова этой функции с третьим параметром:

```dart
assert(say('Bob', 'Howdy', 'smoke signal') ==
    'Bob says Howdy with a smoke signal');
```

### Значения параметров по-умолчанию

Ваша функция может использовать `=` для определения значений по умолчанию для именованных и позиционных параметров. Значения по умолчанию должны быть константами времени компиляции.
Если значение по-умолчанию не указано, значением по умолчанию является `null`.

```dart
void enableFlags({bool bold = false, bool hidden = false}) {...}
// bold будет true; hidden - false.
enableFlags(bold: true);
```

> Примечание об устаревании: Старый код может использовать двоеточие (`:`) вместо `=` для установки значений по-умолчанию именованных параметров. Причина в том, что изначально только `:` поддерживали именованные параметры. Это уже устарело, поэтому мы рекомендуем использовать `=`, чтобы указать значения по-умолчанию.

В следующем примере показано, как установить значения по-умолчанию для позиционных параметров:

```dart
String say(String from, String msg,
    [String device = 'carrier pigeon', String mood]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  if (mood != null) {
    result = '$result (in a $mood mood)';
  }
  return result;
}

assert(say('Bob', 'Howdy') ==
    'Bob says Howdy with a carrier pigeon');
```

Вы также можете передать списки или карты в качестве значений по умолчанию. В следующем примере определяется функция doStuff (), которая задает список по-умолчанию для параметра list и карту по-умолчанию для параметра gifts.

```dart
void doStuff(
    {List<int> list = const [1, 2, 3],
    Map<String, String> gifts = const {
      'first': 'paper',
      'second': 'cotton',
      'third': 'leather'
    }}) {
  print('list:  $list');
  print('gifts: $gifts');
}
```

### Функция main()

Каждое приложение должно иметь функцию `main()`, которая служит точкой входа в приложение. Функция `main()` возвращает `void` и имеет необязательный параметр `List<String>` для аргументов.

```dart
void main() {
  querySelector('#sample_text_id')
    ..text = 'Click me!'
    ..onClick.listen(reverseText);
}
```

> Примечание. Синтаксис .. в предыдущем коде называется каскадом. С помощью каскадов вы можете выполнять несколько операций над элементами одного объекта.

Вот пример функции `main()` для приложения командной строки, которое принимает аргументы:

```dart
void main(List<String> arguments) {
  print(arguments);

  assert(arguments.length == 2);
  assert(int.parse(arguments[0]) == 1);
  assert(arguments[1] == 'test');
}
```

### Функции как объекты

Вы можете передать функцию в качестве параметра другой функции. Например:

```dart
void printElement(int element) {
  print(element);
}

var list = [1, 2, 3];

list.forEach(printElement);
```

Вы также можете назначить функцию переменной, например:

```dart
var loudify = (msg) => '!!! ${msg.toUpperCase()} !!!';
assert(loudify('hello') == '!!! HELLO !!!');
```

## Анонимные функции

Большинство функций имеют имена, такие как `main()` или `printElement()`. Вы также можете создать безымянную функцию, называемую анонимной функцией, иногда лямбда-выражением или замыканием. Вы можете назначить анонимную функцию переменной, чтобы, например, вы могли добавить или удалить ее из коллекции.

Анонимная функция выглядит аналогично именованной функции

В следующем примере определяется анонимная функция с нетипизированным параметром item. Функция, вызываемая для каждого элемента в списке, печатает строку, содержащую значение по указанному индексу.

```dart
var list = ['apples', 'bananas', 'oranges'];
list.forEach((item) {
  print('${list.indexOf(item)}: $item');
});
```

Если функция содержит только один оператор, вы можете сократить его, используя обозначение стрелки.

```dart
list.forEach((item) => print('${list.indexOf(item)}: $item'));
```

### Возврат значений

Все функции возвращают значение. Если возвращаемое значение не указано, инструкция `return null;` неявно добавляется к телу функции.

```dart
foo() {}

assert(foo() == null);
```

Пример явного возврата значения из функции:

```dart
int calc(){
  int x = 100;
  int y = 1;
  return x + y;
}

assert(calc() == 101);
```

Пример сокращенного возврата значения для простых функций:

```dart
int calc()=> 100 + 1;
assert(calc() == 101);
```

## Операторы

Dart определяет операторы, показанные в следующей таблице. Вы можете переопределить многие из этих операторов

| Описание           | Оператор                                     |
| ------------------ |:---------------------------------------------|
| постфикс           | expr++    expr--    ()    []    .    ?.      |
| префикс            | -expr    !expr    ~expr    ++expr    --expr  |
| мультипликативный  | *    /    %  ~/                              |
| добавление         | +    -                                       |
| сдвиг              | <<    >>    >>>                              |
| побитовое И        | &                                            |
| побитовое XOR      | ^                                            |
| Побитовое ИЛИ      | \|                                           |
| реляционный тест   | >=    >    <=    <    as    is    is!        |
| равенство          | ==    !=                                     |
| логическое И       | &&                                           |
| логическое ИЛИ     | \|\|                                         |
| проверка на null   | ??                                           |
| условие            | expr1 ? expr2 : expr3                        |
| каскад             | ..                                           |
| сокращенная мат    | =    *=    /=   +=   -=   &=   ^=   etc.     |

Когда вы используете операторы, вы создаете выражения. Вот несколько примеров выражений:

```dart
a++ // a + 1
a + b
a = b // присваевание значения b в переменную a
a == b // сравнение a и b
c ? a : b // если с тогда а, иначе b
a is T // a как T (Т - тип данных)
```

В таблице операторов каждый оператор имеет более высокий приоритет, чем операторы в строках, следующих за ним. Например, мультипликативный оператор `%` имеет более высокий приоритет, чем (и, следовательно, выполняется раньше) оператор равенства `==`, который имеет более высокий приоритет, чем логический оператор И `&&`. Этот приоритет означает, что следующие две строки кода выполняются одинаково:

```dart
// Скобки улучшают читабельность.
if ((n % i == 0) && (d % i == 0)) ...

// Труднее читать, но эквивалентно.
if (n % i == 0 && d % i == 0) ..
```

### Арифметические операторы

Dart поддерживает обычные арифметические операторы, как показано в следующей таблице

| Оператор | Описание                            |
| -------- | ----------------------------------- |
| +        | Сложение                            |
| -        | Вычитание                           |
| -expr    | Отрицательное число                 |
| *        | Умножение                           |
| /        | Деление                             |
| ~/       | Деление без остатка                 |
| %        | Остаток от деления                  |

Пример:

```dart
assert(2 + 3 == 5);
assert(2 - 3 == -1);
assert(2 * 3 == 6);
assert(5 / 2 == 2.5); // Результат число с плавающей точкой
assert(5 ~/ 2 == 2); // Результат целое число
assert(5 % 2 == 1); // Остаток от деления

assert('5/2 = ${5 ~/ 2} r ${5 % 2}' == '5/2 = 2 r 1');
```

Dart также поддерживает префиксные и постфиксные операторы увеличения и уменьшения

| Оператор | Описание                            |
| -------- | ----------------------------------- |
| ++var    | var = var + 1                       |
| var++    | var = var + 1                       |
| var--    | var = var – 1                       |
| --var    | var = var – 1                       |

Пример:

```dart
var a, b;

a = 0;
b = ++a; // Увеличит a, прежде чем b получит свое значение.
assert(a == b); // 1 == 1

a = 0;
b = a++; // Увеличит a, ПОСЛЕ того, как b получит свое значение.
assert(a != b); // 1 != 0

a = 0;
b = --a; // Уменьшит a, прежде чем b получит свое значение..
assert(a == b); // -1 == -1

a = 0;
b = a--; // Уменьшит a, ПОСЛЕ того, как b получит свое значение.
assert(a != b); // -1 != 0
```

### Операторы сравнивания и отношения

В следующей таблице перечислены операторы равенства и операторы отношений

| Оператор | Описание                            |
| -------- | ----------------------------------- |
| ==    | сравнение                              |
| !=    | не равно                               |
| >     | больше чем                             |
| <     | меньше чем                             |
| >=    | больше или равно                       |
| <=    | меньше или равно                       |

Чтобы проверить, представляют ли два объекта `x` и `y` одно и то же, используйте оператор `==`. (В редком случае, когда вам нужно знать, являются ли два объекта одним и тем же объектом, используйте функцию `identifier()`.) Вот как работает оператор `==`:

```dart
assert(2 == 2);
assert(2 != 3);
assert(3 > 2);
assert(2 < 3);
assert(3 >= 3);
assert(2 <= 3);
```

> Результатом таких выражений всегда будет булево `true` или `false`

### Операторы проверки типов

| Оператор | Описание                            |
| -------- | ----------------------------------- |
| as    | как тип                                |
| is    | TRUE, если объект имеет указанный тип  |
| is!   | FALSE, если объект имеет указанный тип |

Используйте оператор as для приведения объекта к определенному типу.

```dart
(emp as Person).firstName = 'Bob';
```

Данный пример посути является сокращенной записью:

```dart
if (emp is Person) {
  // Type check
  emp.firstName = 'Bob';
}
```

Где оператор `is` проверяет является ли `emp` типом `Person`

> Обратите внимание: Эти примеры НЕ являются эквивалентами! В первом случае если `emp == null` или `emp` не является типом `Person` вы получите исключение, второй же пример не выдаст ошибок.

### Операторы присваивания

Вы уже знаете, что присвоить значение можно при помощи оператора `=`. В случае когда нужно присвоить заначение только если целевая переменная `null` следует использовать `??=`:

```dart
// Присваивание значения в а в любом случае
a = value;
// Присваивание значения в b ТОЛЬКО если b == null иначе, ее значение не изменится
b ??= value;
```

Составные операторы присваивания, такие как + =, объединяют операцию с присваиванием.

```dart
a += a // a = a+b
```

Данная запись действует для всех арифметических операторов.

```
–=	/=	%=		
+=	*=	~/=		
```

### Логические операторы

Вы можете инвертировать или комбинировать логические выражения, используя логические операторы.

| Оператор | Описание                            |
| -------- | ----------------------------------- |
| !expr    | инверсия значения                   |
| ||       | логическое ИЛИ                      |
| &&       | логическое И                        |

### Условные выражения

В Dart есть два оператора, которые позваляют использовать сокращенную запись `if-else`:

`condition ? expr1 : expr2`

Если условие верно, вычислится и вернется результат первого выражания, в противном случае второго.

`expr1 ?? expr2`

Если первое выражение не `null` вернется оно, иначе вычислится и вернется результат второго выражения.

Пример использования:

```dart
var visibility = isPublic ? 'public' : 'private';
```

Если логическое выражение проверяет `null`, рассмотрите возможность использования ??.

```dart
String playerName(String name) => name ?? 'Guest';
```

Такая запись достаточна проста в понимании, хотя и является полным эквивалентом:

```dart
// Очень длинная запись
String playerName(String name) {
  if (name != null) {
    return name;
  } else {
    return 'Guest';
  }
}

// Более короткая, но все еще трудночитаемая
String playerName(String name) => name != null ? name : 'Guest';
```

### Каскады

TODO

### Другие операторы

| Оператор | Описание                            |
| -------- | ----------------------------------- |
| () | Вызов функции(иногда соправождается передачей аргументов в функцию) |
| [] | Определение массива                      |
| {} | Определение славоря                      |
| .  | Вызов методов                            |
| ?. | Вызов методов с проверкой на null        |

## Ветвление. Операторы управления потоком

Вы можете контролировать поток своего кода, используя следующие операторы:

- if и else
- цикл for
- while и do-while циклы
- break и continue
- switch и case
- assert

Вы также можете влиять на поток, используя try-catch и throw, как описано в разделе «Исключения».

### if else

Dart поддерживает операторы if с дополнительными операторами else, как показано в следующем примере.

```dart
if (isRaining()) {
  you.bringRainCoat();
} else if (isSnowing()) {
  you.wearJacket();
} else {
  car.putTopDown();
}
```

В отличие от JavaScript, условия должны использовать ТОЛЬКО логические значения.

### Цикл For

Вы можете выполнять итерации со стандартным циклом `for`. Например:

```dart
var message = StringBuffer('Dart is fun');
for (var i = 0; i < 5; i++) {
  message.write('!');
}
```

Замыкания внутри циклов `for` в Dart фиксируют значение индекса, избегая распространенной ошибки, обнаруженной в JavaScript.

```dart
var callbacks = [];
for (var i = 0; i < 2; i++) {
  callbacks.add(() => print(i));
}
callbacks.forEach((c) => c());
```

Если объект, который вы используете, является Iterable, вы можете использовать метод `forEach()`. Использование `forEach()` является хорошим вариантом, если вам не нужно знать текущий счетчик итераций:

```dart
candidates.forEach((candidate) => candidate.interview());
```

Итерируемые объекты, такие как `List` и `Set`, также поддерживают форму итерации `for-in`:

```dart
var collection = [0, 1, 2];
for (var x in collection) {
  print(x); // 0 1 2
}
```

### While и do-while

Цикл `while` перед исполнением тела цикла, проверяет условие

```dart
while (!isDone()) {
  doSomething();
}
```

Цикл `do while` сначала исполняет тело цикла, а затем проверяет условие

```dart
do {
  printLine();
} while (!atEndOfPage());
```

### Break и continue

Используйте `break` для прирывания цикла

```dart
while (true) {
  if (shutDownRequested()) break;
  processIncomingRequests();
}
```

Для пропуска текущей итерации используйте `continue`:

```dart
for (int i = 0; i < candidates.length; i++) {
  var candidate = candidates[i];
  if (candidate.yearsExperience < 5) {
    continue;
  }
  candidate.interview();
}
```

Даный пример можно написать по-другому, если вы используете Iterable, такой как `List` или `Set`:

```dart
candidates
    .where((c) => c.yearsExperience >= 5)
    .forEach((c) => c.interview());
```

### Switch case

Оператор `Switch` в Dart сравнивают целочисленные, строковые или константы времени компиляции, используя `==`. Все сравниваемые объекты должны быть экземплярами одного и того же класса (а не каких-либо его подтипов), и класс не должен переопределять `==`.

Каждый `case` должне заканчиватся `break, continue, throw или return`

```dart
var command = 'OPEN';
switch (command) {
  case 'CLOSED':
    executeClosed();
    break;
  case 'PENDING':
    executePending();
    break;
  case 'APPROVED':
    executeApproved();
    break;
  case 'DENIED':
    executeDenied();
    break;
  case 'OPEN':
    executeOpen();
    break;
  default:
    executeUnknown();
}
```

В следующем примере в операторе `case` пропущен оператор `break`, что приводит к ошибке:

```dart
var command = 'OPEN';
switch (command) {
  case 'OPEN':
    executeOpen();
    // ERROR: Пропущен break

  case 'CLOSED':
    executeClosed();
    break;
}
```

Тем не менее, Dart поддерживает пустые предложения case:

```dart
var command = 'CLOSED';
switch (command) {
  case 'CLOSED':
  case 'NOW_CLOSED':
    executeNowClosed();
    break;
}
```

### Assert

Во время разработки можно использовать оператор `assert()`. Это оператор необязательного сообщения об ошибке. Данные оператор будет пробущен при компеляции production кода.

```dart
// проверка переменной на null
assert(text != null);

// проверка меньше ли значение переменно 100.
assert(number < 100);

// проверка является ли адресс https.
assert(urlString.startsWith('https'));
```

Чтобы прикрепить сообщение к утверждению, добавьте строку в качестве второго аргумента для утверждения.

```dart
assert(urlString.startsWith('https'),
    'URL ($urlString) should start with "https".');
```

Первым аргументом `assert` может быть любое выражение, результат которого логическое значение. Если значение выражения истинно, печатается утверждение и выполнение продолжается. Если значение равно `false`, утверждение не выполняется и генерируется исключение (`AssertionError`).

## Исключения
 
## Классы
